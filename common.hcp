#include <cstring> // strlen()

#include <buffer_handle/character.hpp> // character()
#include <buffer_handle/string.hpp> // string()
#include <buffer_handle/timezone.hpp> // universal_timezone_t
#include <buffer_handle/token.hpp> // carriage_return() new_line() colon() space()

namespace buffer_handle_http_header
{
  template<config Config, action Action> inline
  char * crlf(char * buffer)
  {
    buffer = buffer_handle::carriage_return<Config, Action>(buffer);
    buffer = buffer_handle::new_line<Config, Action>(buffer);

    return buffer;
  }

  template<action Action>
  char * field_(char * buffer, const char * value, std::size_t length)
  {
    buffer = buffer_handle::string<config::static_, Action>(buffer, value, length);
    buffer = buffer_handle::colon<config::static_, Action>(buffer);
    buffer = buffer_handle::space<config::static_, Action>(buffer);

    return buffer;
  }

  template<config Config, typename I, typename MaxDigits>
  template<action Action, class Itoa> inline
  char * integral_number_field_t<Config, I, MaxDigits>::handle(char * buffer, const char * field, I value, const Itoa & itoa /* = Itoa() */)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    buffer = buffer_handle::integral_number_t<Config, align::right, ' ', I, MaxDigits>::template handle<Action, Itoa>(buffer, value, itoa);

    return buffer;
  }

  template<config Config, typename I, typename MaxDigits>
  template<action Action, class Itoa> inline
  char * long_integral_number_field_t<Config, I, MaxDigits>::handle(char * buffer, const char * field, I value, const Itoa & itoa /* = Itoa() */)
  {
    buffer = field_<Config, Action>(buffer, field, std::strlen(field));

    buffer = buffer_handle::long_integral_number_t<Config, align::right, ' ', I, MaxDigits>::template handle<Action, Itoa>(buffer, value, itoa);

    return buffer;
  }

  template<config Config>
  template<action Action> inline
  char * string_field_t<Config>::handle(char * buffer, const char * field, const char * value, std::size_t length)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    buffer = buffer_handle::string_t<Config, align::right, ' '>::template handle<Action>(buffer, value, length);

    return buffer;
  }

  template<config Config>
  template<action Action> inline
  char * long_string_field_t<Config>::handle(char * buffer, const char * field, const char * value, std::size_t length)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    buffer = buffer_handle::long_string_t<Config, align::right, ' '>::template handle<Action>(buffer, value, length);

    return buffer;
  }

  template<config Config, action Action,
	     typename Weekday, typename Day, typename Month, typename Year,
	     typename Hours, typename Minutes, typename Seconds> inline
  char * date(char * buffer, const char * field,
	      Weekday weekday, Day day, Month month, Year year,
	      Hours hours, Minutes minutes, Seconds seconds)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    typedef buffer_handle::universal_timezone_t<config::static_, align::left, ' '> timezone_type;

    buffer = buffer_handle::rfc1123::date<Config, true, true, timezone_type, Action,
					  Weekday, Day, Month, Year,
					  Hours, Minutes, Seconds>
      (buffer,
       weekday, day, month, year,
       hours, minutes, seconds,
       timezone_type(buffer_handle::universal_timezone::GMT));

    return buffer;
  }

  template<config Config, action Action> inline
  char * date(char * buffer, const char * field, std::tm value)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    typedef buffer_handle::universal_timezone_t<config::static_, align::left, ' '> timezone_type;

    buffer = buffer_handle::rfc1123::date<Config, true, true, timezone_type, Action>
      (buffer, value, timezone_type(buffer_handle::universal_timezone::GMT));

    return buffer;
  }

  template<config Config, bool ListSetMaxLength>
  container_field_t<Config, ListSetMaxLength>::container_field_t() :
    buffer_handle::container_t<Config, align::right, ' '>(0)
  {

  }

  template<config Config, bool ListSetMaxLength>
  template<action Action, class Iterator, class Element, class Separator> inline
  char * container_field_t<Config, ListSetMaxLength>::handle(char * buffer, const char * field, const Iterator & begin, const Iterator & end, Element & element, Separator & separator)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    if(ListSetMaxLength
       && Config == config::dynamic
       && (Action == action::size || Action == action::prepare))
      {
	this->max_length = (std::size_t)buffer_handle::container
	  <config::static_, align::right, ' ', action::size, Element, Separator, Iterator>
	  (nullptr, begin, end, this->max_length, element, separator);
      }

    buffer = buffer_handle::container_t<Config, align::right, ' '>:: template handle<Action, Iterator, Element, Separator>(buffer, begin, end, element, separator);

    return buffer;
  }

  template<config Config, bool ListSetMaxLength>
  long_container_field_t<Config, ListSetMaxLength>::long_container_field_t() :
    buffer_handle::container_t<Config, align::right, ' '>(0)
  {

  }

  template<config Config, bool ListSetMaxLength>
  template<action Action, class Iterator, class Element, class Separator> inline
  char * long_container_field_t<Config, ListSetMaxLength>::handle(char * buffer, const char * field, const Iterator & begin, const Iterator & end, Element & element, Separator & separator)
  {
    buffer = field_<Action>(buffer, field, std::strlen(field));

    if(ListSetMaxLength
       && Config == config::dynamic
       && (Action == action::size || Action == action::prepare))
      {
	this->max_length = (std::size_t)buffer_handle::container
	  <config::static_, align::right, ' ', action::size, Element, Separator, Iterator>
	  (nullptr, begin, end, this->max_length, element, separator, this->max_length);
      }

    buffer = buffer_handle::long_container_t<Config, align::right, ' '>:: template handle<Action, Iterator, Element, Separator>(buffer, begin, end, element, separator);

    return buffer;
  }

  template<char Separator>
  template<config Config, action Action> inline
  char * character_separator_t<Separator>::handle(char * buffer) const
  {
    return buffer_handle::character<Config, Action>(buffer, Separator);
  }
};
