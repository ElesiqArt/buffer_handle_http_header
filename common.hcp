#include <cstring> // strlen() memcpy()
#include <type_traits> // underlying_type

#include <buffer_handle/character.hpp> // character()
#include <buffer_handle/helper.hpp> // character_separator_t must_write()
#include <buffer_handle/string.hpp> // string()
#include <buffer_handle/timezone.hpp> // universal_timezone_t
#include <buffer_handle/token.hpp> // carriage_return() comma(), new_line() colon() space()

namespace buffer_handle_http_header
{
  template<config Config, action Action> inline
  char * crlf(char * buffer)
  {
    buffer = buffer_handle::carriage_return<Config, Action>(buffer);
    buffer = buffer_handle::new_line<Config, Action>(buffer);

    return buffer;
  }

  template<action Action>
  char * field_(char * buffer, const char * value, std::size_t length)
  {
    buffer = buffer_handle::string<config::static_, Action>(buffer, value, length);
    buffer = buffer_handle::colon<config::static_, Action>(buffer);
    buffer = buffer_handle::space<config::static_, Action>(buffer);

    return buffer;
  }

  template<action Action>
  char * field_(char * buffer, const char * value)
  {
    return field_<Action>(buffer, value, std::strlen(value));
  }

  template<config Config, typename I, typename MaxDigits, bool IsLong>
  template<action Action, class Itoa> inline
  char * integral_number_field_t<Config, I, MaxDigits, IsLong>::handle(char * buffer, const char * field, I value, const Itoa & itoa /* = Itoa() */)
  {
    buffer = field_<Action>(buffer, field);

    buffer = buffer_handle::integral_number_t<Config, align::right, ' ', I, MaxDigits, IsLong>::template handle<Action, Itoa>(buffer, value, itoa);

    return buffer;
  }

  template<config Config, bool IsLong>
  template<action Action> inline
  char * string_field_t<Config, IsLong>::handle(char * buffer, const char * field, const char * value, std::size_t length)
  {
    buffer = field_<Action>(buffer, field);

    buffer = buffer_handle::string_t<Config, align::right, ' '>::template handle<Action>(buffer, value, length);

    return buffer;
  }

  template<config Config, action Action,
	     typename Weekday, typename Day, typename Month, typename Year,
	     typename Hours, typename Minutes, typename Seconds> inline
  char * date(char * buffer, const char * field,
	      Weekday weekday, Day day, Month month, Year year,
	      Hours hours, Minutes minutes, Seconds seconds)
  {
    buffer = field_<Action>(buffer, field);

    typedef buffer_handle::universal_timezone_t<config::static_, align::left, ' '> timezone_type;

    buffer = buffer_handle::rfc1123::date<Config, true, true, timezone_type, Action,
					  Weekday, Day, Month, Year,
					  Hours, Minutes, Seconds>
      (buffer,
       weekday, day, month, year,
       hours, minutes, seconds,
       timezone_type(buffer_handle::universal_timezone::GMT));

    return buffer;
  }

  template<config Config, action Action> inline
  char * date(char * buffer, const char * field, std::tm value)
  {
    buffer = field_<Action>(buffer, field);

    typedef buffer_handle::universal_timezone_t<config::static_, align::left, ' '> timezone_type;

    buffer = buffer_handle::rfc1123::date<Config, true, true, timezone_type, Action>
      (buffer, value, timezone_type(buffer_handle::universal_timezone::GMT));

    return buffer;
  }

  template<config Config, bool ListSetMaxLength, bool IsLong>
  void container_field_t<Config, ListSetMaxLength, IsLong>::set_max_length(std::size_t length)
  {
    this->set_max_length(length);
  }

  template<config Config, bool ListSetMaxLength, bool IsLong>
  template<class Iterator, class Element, class Separator> inline
  void container_field_t<Config, ListSetMaxLength, IsLong>::set_max_length(const Iterator & begin, const Iterator & end, Element & element, Separator & separator)
  {
    this->max_length = (std::size_t)buffer_handle::container
      <config::static_, align::right, ' ', action::size, Element, Separator, Iterator>
      (nullptr, begin, end, this->max_length, element, separator);
  }

  template<config Config, bool ListSetMaxLength, bool IsLong>
  template<action Action, class Iterator, class Element, class Separator> inline
  char * container_field_t<Config, ListSetMaxLength, IsLong>::handle(char * buffer, const char * field, const Iterator & begin, const Iterator & end, Element & element, Separator & separator)
  {
    buffer = field_<Action>(buffer, field);

    if(ListSetMaxLength
       && Config == config::dynamic
       && (Action == action::size || Action == action::prepare))
      {
	std::size_t dummy_max_length;
	this->set_max_length((std::size_t)buffer_handle::container
			     <config::static_, align::right, ' ', action::size, Element, Separator, Iterator>
			     (nullptr, begin, end, dummy_max_length, element, separator));
      }

    buffer = buffer_handle::container_t<Config, align::right, ' '>:: template handle<Action, Iterator, Element, Separator>(buffer, begin, end, element, separator);

    return buffer;
  }

  template<typename EnumSet>
  template<typename T> inline
  set_iterator_t<EnumSet>::set_iterator_t(EnumSet value, T max_number_of_elements /* = 0 */) :
    value(value),
    mask((EnumSet)(max_number_of_elements == 0 ? 0 : 1 << max_number_of_elements))
  {
    this->operator ++ ();//Search for the first available value
  }

  template<typename EnumSet> inline
  set_iterator_t<EnumSet> & set_iterator_t<EnumSet>::operator ++ ()
  {
    do
      {
	this->mask = (EnumSet)((typename std::underlying_type<EnumSet>::type)this->mask >> 1);
      }
    while((EnumSet)0 < this->mask
	  && !((typename std::underlying_type<EnumSet>::type)this->value
	       & (typename std::underlying_type<EnumSet>::type)this->mask));

    return *this;
  }

  template<typename EnumSet> inline
  set_iterator_t<EnumSet> set_iterator_t<EnumSet>::operator ++ (int)
  {
    self_type old = *this;

    this->operator ++ ();

    return old;
  }

  template<typename EnumSet> inline
  bool set_iterator_t<EnumSet>::operator == (const self_type it) const
  {
    return this->mask == it.mask;
  }

  template<typename EnumSet> inline
  bool set_iterator_t<EnumSet>::operator != (const self_type it) const
    {
      return ! this->operator == (it);
    }

  template<typename EnumSet> inline
  EnumSet set_iterator_t<EnumSet>::operator * () const
  {
    return this->mask;
  }

  template<class EnumSetName>
  template<config Config, action Action> inline
  char * set_iterator_handler_t<EnumSetName>::handle(char * buffer, typename EnumSetName::value_type element) const
  {
    const char * value = EnumSetName::get(element);

    if(buffer_handle::must_write(Config, Action))
      {
	std::memcpy(buffer, value, std::strlen(value));
      }

    return buffer + std::strlen(value);
  }

  template<config Config, class EnumSetName, bool IsLong>
  template<action Action> inline
  char * set_field_t<Config, EnumSetName, IsLong>::handle(char * buffer, const char * field, typename EnumSetName::value_type value)
  {
    typedef set_iterator_t<typename EnumSetName::value_type> iterator_type;
    typedef const set_iterator_handler_t<EnumSetName> handler_type;
    typedef const typename buffer_handle::character_separator_t<','> separator_type;

    return container_field_t<Config, true, IsLong>::template handle
      <Action, iterator_type, handler_type, separator_type>
      (buffer, field, iterator_type(value, EnumSetName::count), iterator_type(value),
       handler_type(), separator_type());
  }

  //For library local purpose only
  template<action Action>
  char * attribute(char * buffer, const char * value)
  {
    return buffer_handle::string<config::static_, Action>(buffer, value, std::strlen(value));
  }
};
